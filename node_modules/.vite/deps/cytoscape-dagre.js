import {
  require_dagre
} from "./chunk-ZAEOQBMV.js";
import {
  __commonJS
} from "./chunk-5FUTL2UF.js";

// node_modules/cytoscape-dagre/cytoscape-dagre.js
var require_cytoscape_dagre = __commonJS({
  "node_modules/cytoscape-dagre/cytoscape-dagre.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_dagre());
      else if (typeof define === "function" && define.amd)
        define(["dagre"], factory);
      else if (typeof exports === "object")
        exports["cytoscapeDagre"] = factory(require_dagre());
      else
        root["cytoscapeDagre"] = factory(root["dagre"]);
    })(exports, function(__WEBPACK_EXTERNAL_MODULE__4__) {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 0);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var impl = __webpack_require__(1);
            var register = function register2(cytoscape2) {
              if (!cytoscape2) {
                return;
              }
              cytoscape2("layout", "dagre", impl);
            };
            if (typeof cytoscape !== "undefined") {
              register(cytoscape);
            }
            module2.exports = register;
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var isFunction = function isFunction2(o) {
              return typeof o === "function";
            };
            var defaults = __webpack_require__(2);
            var assign = __webpack_require__(3);
            var dagre = __webpack_require__(4);
            function DagreLayout(options) {
              this.options = assign({}, defaults, options);
            }
            DagreLayout.prototype.run = function() {
              var options = this.options;
              var layout = this;
              var cy = options.cy;
              var eles = options.eles;
              var getVal = function getVal2(ele, val) {
                return isFunction(val) ? val.apply(ele, [ele]) : val;
              };
              var bb = options.boundingBox || {
                x1: 0,
                y1: 0,
                w: cy.width(),
                h: cy.height()
              };
              if (bb.x2 === void 0) {
                bb.x2 = bb.x1 + bb.w;
              }
              if (bb.w === void 0) {
                bb.w = bb.x2 - bb.x1;
              }
              if (bb.y2 === void 0) {
                bb.y2 = bb.y1 + bb.h;
              }
              if (bb.h === void 0) {
                bb.h = bb.y2 - bb.y1;
              }
              var g = new dagre.graphlib.Graph({
                multigraph: true,
                compound: true
              });
              var gObj = {};
              var setGObj = function setGObj2(name, val) {
                if (val != null) {
                  gObj[name] = val;
                }
              };
              setGObj("nodesep", options.nodeSep);
              setGObj("edgesep", options.edgeSep);
              setGObj("ranksep", options.rankSep);
              setGObj("rankdir", options.rankDir);
              setGObj("align", options.align);
              setGObj("ranker", options.ranker);
              setGObj("acyclicer", options.acyclicer);
              g.setGraph(gObj);
              g.setDefaultEdgeLabel(function() {
                return {};
              });
              g.setDefaultNodeLabel(function() {
                return {};
              });
              var nodes = eles.nodes();
              if (isFunction(options.sort)) {
                nodes = nodes.sort(options.sort);
              }
              for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var nbb = node.layoutDimensions(options);
                g.setNode(node.id(), {
                  width: nbb.w,
                  height: nbb.h,
                  name: node.id()
                });
              }
              for (var _i = 0; _i < nodes.length; _i++) {
                var _node = nodes[_i];
                if (_node.isChild()) {
                  g.setParent(_node.id(), _node.parent().id());
                }
              }
              var edges = eles.edges().stdFilter(function(edge2) {
                return !edge2.source().isParent() && !edge2.target().isParent();
              });
              if (isFunction(options.sort)) {
                edges = edges.sort(options.sort);
              }
              for (var _i2 = 0; _i2 < edges.length; _i2++) {
                var edge = edges[_i2];
                g.setEdge(edge.source().id(), edge.target().id(), {
                  minlen: getVal(edge, options.minLen),
                  weight: getVal(edge, options.edgeWeight),
                  name: edge.id()
                }, edge.id());
              }
              dagre.layout(g);
              var gNodeIds = g.nodes();
              for (var _i3 = 0; _i3 < gNodeIds.length; _i3++) {
                var id = gNodeIds[_i3];
                var n = g.node(id);
                cy.getElementById(id).scratch().dagre = n;
              }
              var dagreBB;
              if (options.boundingBox) {
                dagreBB = {
                  x1: Infinity,
                  x2: -Infinity,
                  y1: Infinity,
                  y2: -Infinity
                };
                nodes.forEach(function(node2) {
                  var dModel = node2.scratch().dagre;
                  dagreBB.x1 = Math.min(dagreBB.x1, dModel.x);
                  dagreBB.x2 = Math.max(dagreBB.x2, dModel.x);
                  dagreBB.y1 = Math.min(dagreBB.y1, dModel.y);
                  dagreBB.y2 = Math.max(dagreBB.y2, dModel.y);
                });
                dagreBB.w = dagreBB.x2 - dagreBB.x1;
                dagreBB.h = dagreBB.y2 - dagreBB.y1;
              } else {
                dagreBB = bb;
              }
              var constrainPos = function constrainPos2(p) {
                if (options.boundingBox) {
                  var xPct = dagreBB.w === 0 ? 0 : (p.x - dagreBB.x1) / dagreBB.w;
                  var yPct = dagreBB.h === 0 ? 0 : (p.y - dagreBB.y1) / dagreBB.h;
                  return {
                    x: bb.x1 + xPct * bb.w,
                    y: bb.y1 + yPct * bb.h
                  };
                } else {
                  return p;
                }
              };
              nodes.layoutPositions(layout, options, function(ele) {
                ele = _typeof(ele) === "object" ? ele : this;
                var dModel = ele.scratch().dagre;
                return constrainPos({
                  x: dModel.x,
                  y: dModel.y
                });
              });
              return this;
            };
            module2.exports = DagreLayout;
          },
          /* 2 */
          /***/
          function(module2, exports2) {
            var defaults = {
              // dagre algo options, uses default value on undefined
              nodeSep: void 0,
              // the separation between adjacent nodes in the same rank
              edgeSep: void 0,
              // the separation between adjacent edges in the same rank
              rankSep: void 0,
              // the separation between adjacent nodes in the same rank
              rankDir: void 0,
              // 'TB' for top to bottom flow, 'LR' for left to right,
              align: void 0,
              // alignment for rank nodes. Can be 'UL', 'UR', 'DL', or 'DR', where U = up, D = down, L = left, and R = right
              acyclicer: void 0,
              // If set to 'greedy', uses a greedy heuristic for finding a feedback arc set for a graph.
              // A feedback arc set is a set of edges that can be removed to make a graph acyclic.
              ranker: void 0,
              // Type of algorithm to assigns a rank to each node in the input graph.
              // Possible values: network-simplex, tight-tree or longest-path
              minLen: function minLen(edge) {
                return 1;
              },
              // number of ranks to keep between the source and target of the edge
              edgeWeight: function edgeWeight(edge) {
                return 1;
              },
              // higher weight edges are generally made shorter and straighter than lower weight edges
              // general layout options
              fit: true,
              // whether to fit to viewport
              padding: 30,
              // fit padding
              spacingFactor: void 0,
              // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
              nodeDimensionsIncludeLabels: false,
              // whether labels should be included in determining the space used by a node
              animate: false,
              // whether to transition the node positions
              animateFilter: function animateFilter(node, i) {
                return true;
              },
              // whether to animate specific nodes when animation is on; non-animated nodes immediately go to their final positions
              animationDuration: 500,
              // duration of animation in ms if enabled
              animationEasing: void 0,
              // easing of animation if enabled
              boundingBox: void 0,
              // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
              transform: function transform(node, pos) {
                return pos;
              },
              // a function that applies a transform to the final node position
              ready: function ready() {
              },
              // on layoutready
              sort: void 0,
              // a sorting function to order the nodes and edges; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
              // because cytoscape dagre creates a directed graph, and directed graphs use the node order as a tie breaker when
              // defining the topology of a graph, this sort function can help ensure the correct order of the nodes/edges.
              // this feature is most useful when adding and removing the same nodes and edges multiple times in a graph.
              stop: function stop() {
              }
              // on layoutstop
            };
            module2.exports = defaults;
          },
          /* 3 */
          /***/
          function(module2, exports2) {
            module2.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {
              for (var _len = arguments.length, srcs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                srcs[_key - 1] = arguments[_key];
              }
              srcs.forEach(function(src) {
                Object.keys(src).forEach(function(k) {
                  return tgt[k] = src[k];
                });
              });
              return tgt;
            };
          },
          /* 4 */
          /***/
          function(module2, exports2) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE__4__;
          }
          /******/
        ])
      );
    });
  }
});
export default require_cytoscape_dagre();
//# sourceMappingURL=cytoscape-dagre.js.map
